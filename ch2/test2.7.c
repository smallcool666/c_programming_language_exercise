#include <stdio.h>
#include <windows.h>

/**
 * 练习2-7 编写一个函数invert(x,p,n)，该函数返回对x执行下列操作后的结 果值：将x中从第p位开始的n个（二进制）位求反
 * （即，1变成0，0变成1)，x的其余各 位保持不变。
 * 
 * 第p位是从右边数的
 * 和书中示例一样，假设最右边一位是第0位
 */

int invert(int x, int p, int n);
int invert1(int x, int p, int n);

int main()
{
    //256 = 10000000, 结果应该为10001100 = 268
    printf("%d, %d, %d\n", 256, 63, invert(256, 3, 2));
    printf("%d, %d, %d\n", 256, 63, invert1(256, 3, 2));
    system("pause");
    return 0;
}
int invert(int x, int p, int n)
{
    // ~0 << n 制造n位0
    // ~（~0 << n） 制造n位1，其余全是0
    // ~（~0 << n）<< (n-p+1) 把这n个1移动到第p位开始n个bit
    // ~（~（~0 << n）<< (n-p+1)） 取反，把这第p位后n位置为0，其余位都是1，这个就是x的屏蔽码
    // x & ~（~（~0 << n）<< (n-p+1)）x和屏蔽码按位与一下，把第p位开始n个bit的值都置位0

   
    // ~0 << n 制造n位0
    // ~（~0 << n） 制造n位1，其余全是0
    // ~（~0 << n）<< (n-p+1) 把这n个1移动到第p位开始n个bit
    // x & (~（~0 << n）<< (n-p+1)）x和屏蔽码按位与一下，得到第p位开始n个bit的值
    // ~ （x & (~（~0 << n）<< (n-p+1)））取反，第p位开始n个bit与原来相反，其余位全是1，这时得到的是111pxxx111
    //两个按位或一下即可
    return x & ~(~(~0 << n)<< (p-n+1)) | (( ~(x & (~(~0 << n)<< (p-n+1))) & (~(~0 << n)<< (p-n+1))));
}

int invert1(int x, int p, int n)
{
    //使用^异或符号会简单很多
    // 数字x和全是1的屏蔽码异或，原来是0的位会变为1,，原来是1的位会变为0，即取反
    // 和全是0的屏蔽码异或，原来是1的位不变，原来是0的位也不变，即不变

    // ~0 << n 后n位为0，其余位为1
    // ~(~0 << n) 后n位为1，其余位为0
    // ~(~0 << n) << (p-n+1) 第p位开始n位是1，其余位是0
    return x ^ (~(~0 << n) << (p-n+1));
}