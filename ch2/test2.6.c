#include <stdio.h>
#include <windows.h>

/**
 * 练习2-6 编写一个函数setbits(x, p, n, y)，该函数返回对x执行下列操作后 的结果值：将x中从第p位开始的n个（二进制）位
 * 设置为y中最右边n位的值，x的其余 各位保持不变。
 * 
 * 重点是第p位是从右边数的，如果从左边数就没法处理了
 * 和书中示例一样，假设最右边一位是第0位
 */

int setbits(int x, int p, int n, int y);

int main()
{
    //256 = 10000000, 63 = 11111, 结果应该为10001100 = 256 + 8 + 4 = 268
    printf("%d, %d, %d\n", 256, 63, setbits(256, 3, 2, 63));
    system("pause");
    return 0;
}
int setbits(int x, int p, int n, int y)
{
    // ~0 << n 制造n位0
    // ~（~0 << n） 制造n位1，其余全是0
    // ~（~0 << n）<< (n-p+1) 把这n个0移动到第p位开始n个bit
    // ~（~（~0 << n）<< (n-p+1)） 取反，把这第p位后n位置为0，其余位都是1，这个就是x的屏蔽码
    // x & ~（~（~0 << n）<< (n-p+1)）x和屏蔽码按位与一下，把第p位开始n个bit的值都置位0

    // ~（~0 << n）这个是y的屏蔽码，最右边n位都是1，其余位是0
    // y & ~（~0 << n）得到y的最右边n位
    // （y & ~（~0 << n））<< （p-n+1）把这n位挪到第p位开始的位置

    //两个按位或一下即可
    return x & ~(~(~0 << n)<< (p-n+1)) | ((y & ~(~0 << n))<< (p-n+1));
}